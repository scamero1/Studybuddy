Este proyecto, StudyBuddy, es una aplicación de escritorio desarrollada en Java con Swing. Lo construimos en equipo y, aunque la mayor parte del código la hicimos nosotros, en algunos momentos usamos inteligencia artificial como apoyo cuando nos sentíamos bloqueados con el diseño o no sabíamos bien cómo estructurar ciertas partes. La IA nunca reemplazó nuestro trabajo, pero sí nos ayudó a aclarar conceptos y darnos un poco de dirección cuando teníamos la idea en la cabeza pero no sabíamos cómo aterrizarla bien en el código.
El desarrollo de StudyBuddy combina trabajo manual, aprendizaje sobre la marcha y algunas guías puntuales generadas con IA. La IA participó especialmente en el diseño de la estructura orientada a objetos: la clase principal studybuddy.StudyBuddy junto a sus clases internas como Note, User, UserStore, NoteStore, PublicStore y StudyBuddyFrame, que están en el archivo Java que va desde la línea 1 hasta la 991. También apoyó en la creación de la lógica de resumen y extracción de palabras clave mediante frecuencia de términos, específicamente en los métodos summarize, keywords, termFreq y scoreSentence. Además, algunas partes de la interfaz gráfica de usuario en Swing  como la distribución de paneles, las acciones de botones y el tema visual fueron asistidas por IA. Lo mismo ocurrió con la parte opcional de integración con la API de Groq, donde se usaron clases como AiService y GroqAiService para manejar prompts y peticiones HTTP. Incluso el archivo de pruebas StudyBuddyTests.java también recibió algo de ayuda para las validaciones de hash, roundtrip JSON y algunas pruebas funcionales. Sin embargo, todo esto sirvió más como guía. La estructura final, los ajustes, correcciones y la lógica que terminó funcionando fue trabajo nuestro.
Para avanzar más rápido, nos reunimos en la casa de Sebastián y fue ahí donde más desarrollamos. Poder hablar las ideas en persona, revisar los errores juntos y experimentar con el código mientras buscábamos soluciones nos permitió organizarnos mucho mejor. Cada uno aportó desde lo que sabía, y entre todos fuimos resolviendo los problemas uno por uno. Esa reunión fue clave para que el proyecto tomara forma de verdad.
Una de las partes más difíciles fue el manejo de la librería JSON. No la dominábamos completamente, y cada cosa que queríamos implementar generaba algún tipo de error. Pasamos bastante tiempo tratando de entender cómo organizar bien los datos, cómo cargarlos sin dañar los archivos, y cómo asegurarnos de que la aplicación realmente funcionara con esa información. Aunque fue frustrante, también fue el proceso donde más aprendimos, porque nos obligó a comprender mejor la persistencia local y cómo Java maneja archivos JSON de forma manual.
También hicimos varias modificaciones humanas importantes, como ajustar los textos y mensajes de la interfaz para que fueran más claros, revisar la compatibilidad de rutas en Windows, organizar el README, limpiar partes del código, y verificar de manera manual todos los flujos principales de la aplicación: login, registro, CRUD de notas, notas públicas, funciones de IA y pruebas básicas. Todo fue revisado, probado y corregido directamente por nosotros.
Para comprobar que el programa funciona correctamente, basta con compilar y ejecutar los archivos principales usando:
javac -d java/bin java/studybuddy/StudyBuddy.java y luego java -cp java/bin studybuddy.StudyBuddy.
También se pueden correr las pruebas básicas con:
javac -d java/bin java/studybuddy/StudyBuddy.java java/studybuddy/StudyBuddyTests.java y después java -cp java/bin studybuddy.StudyBuddyTests.
Además de las pruebas automáticas, probamos manualmente la creación, edición y eliminación de notas; la opción de marcarlas como públicas; ver las notas públicas; y usar las funciones de resumen, palabras clave y ejercicios tanto con la API de Groq como sin ella. En cada prueba verificamos que los archivos data/users.json, data/notes_<usuario>.json y data/public_notes.json se actualizaran correctamente.
El proyecto tiene algunas limitaciones naturales. Las funciones de IA son completamente opcionales y, si no existe el archivo groq.key o si las rutas no son compatibles, simplemente devuelven un resultado vacío y la interfaz lo comunica al usuario. También hay que tener en cuenta que toda la persistencia está basada en archivos JSON guardados localmente, lo que significa que no es apto para producción sin un servidor o controles adicionales. Los algoritmos de resumen y palabras clave son sencillos y funcionan bien para un nivel principiante, pero no son modelos avanzados.
